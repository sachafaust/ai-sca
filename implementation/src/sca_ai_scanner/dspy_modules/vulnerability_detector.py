"""
DSPy VulnerabilityDetector module with structured signatures.
Provides optimizable vulnerability detection with automatic prompt optimization.
"""

import dspy
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import json
import logging

from ..core.models import Package, CVEFinding, Severity

logger = logging.getLogger(__name__)


class VulnerabilitySignature(dspy.Signature):
    """Structured signature for vulnerability detection."""
    
    # Input fields
    package_name = dspy.InputField(desc="Name of the package to analyze")
    package_version = dspy.InputField(desc="Version of the package")
    ecosystem = dspy.InputField(desc="Package ecosystem (npm, pypi, etc.)")
    
    # Output fields
    vulnerabilities = dspy.OutputField(desc="List of CVE vulnerabilities with id, severity, cvss_score, and description")
    confidence = dspy.OutputField(desc="Confidence score between 0.0 and 1.0")
    reasoning = dspy.OutputField(desc="Explanation of vulnerability detection reasoning")
    
    def validate(self, data: Dict[str, Any]) -> None:
        """Validate signature data."""
        # Validate confidence score
        if 'confidence' in data:
            confidence = data['confidence']
            if not isinstance(confidence, (int, float)) or confidence < 0 or confidence > 1:
                raise ValueError(f"Confidence must be between 0.0 and 1.0, got {confidence}")
        
        # Validate vulnerabilities structure
        if 'vulnerabilities' in data and data['vulnerabilities']:
            for vuln in data['vulnerabilities']:
                if 'cvss_score' in vuln:
                    score = vuln['cvss_score']
                    if score is not None and (score < 0 or score > 10):
                        raise ValueError(f"CVSS score must be between 0.0 and 10.0, got {score}")


@dataclass
class VulnerabilityExample:
    """Example for few-shot learning."""
    package_name: str
    package_version: str
    ecosystem: str
    vulnerabilities: List[Dict[str, Any]]
    confidence: float
    reasoning: str


class VulnerabilityDetector(dspy.Module):
    """DSPy module for structured vulnerability detection."""
    
    def __init__(self, examples: Optional[List[VulnerabilityExample]] = None):
        """Initialize vulnerability detector.
        
        Args:
            examples: Optional few-shot examples for better detection
        """
        super().__init__()
        
        self.signature = VulnerabilitySignature
        self.predictor = dspy.ChainOfThought(self.signature)
        self.examples = examples or []
        self.assertions = []
        
        # Setup few-shot examples if provided
        if self.examples:
            self._setup_examples()
    
    def _setup_examples(self):
        """Setup few-shot examples for the predictor."""
        demonstrations = []
        for example in self.examples:
            demo = dspy.Example(
                package_name=example.package_name,
                package_version=example.package_version,
                ecosystem=example.ecosystem,
                vulnerabilities=example.vulnerabilities,
                confidence=example.confidence,
                reasoning=example.reasoning
            ).with_inputs('package_name', 'package_version', 'ecosystem')
            demonstrations.append(demo)
        
        self.predictor.demos = demonstrations
    
    def detect(self, package: Package) -> Dict[str, Any]:
        """Detect vulnerabilities for a single package.
        
        Args:
            package: Package to analyze
            
        Returns:
            Dictionary with vulnerabilities, confidence, and reasoning
        """
        try:
            # Run prediction
            result = self.predictor(
                package_name=package.name,
                package_version=package.version,
                ecosystem=package.ecosystem
            )
            
            # Parse and validate result
            output = self._parse_result(result)
            
            # Apply assertions
            for assertion_fn, msg in self.assertions:
                if not assertion_fn(output):
                    raise AssertionError(msg)
            
            return output
            
        except Exception as e:
            logger.error(f"Error detecting vulnerabilities for {package.name}:{package.version}: {e}")
            raise
    
    def detect_batch(self, packages: List[Package]) -> List[Dict[str, Any]]:
        """Detect vulnerabilities for multiple packages.
        
        Args:
            packages: List of packages to analyze
            
        Returns:
            List of detection results
        """
        results = []
        for package in packages:
            try:
                result = self.detect(package)
                results.append(result)
            except Exception as e:
                logger.warning(f"Failed to detect vulnerabilities for {package.name}: {e}")
                results.append({
                    'vulnerabilities': [],
                    'confidence': 0.0,
                    'reasoning': f"Detection failed: {str(e)}"
                })
        
        return results
    
    def _parse_result(self, result) -> Dict[str, Any]:
        """Parse and validate predictor result."""
        output = {
            'vulnerabilities': [],
            'confidence': 0.0,
            'reasoning': ''
        }
        
        # Extract vulnerabilities
        if hasattr(result, 'vulnerabilities'):
            vulns = result.vulnerabilities
            if isinstance(vulns, str):
                try:
                    vulns = json.loads(vulns)
                except:
                    vulns = []
            output['vulnerabilities'] = vulns if isinstance(vulns, list) else []
        
        # Extract confidence
        if hasattr(result, 'confidence'):
            conf = result.confidence
            if isinstance(conf, str):
                try:
                    conf = float(conf)
                except:
                    conf = 0.0
            output['confidence'] = max(0.0, min(1.0, conf))
        
        # Extract reasoning
        if hasattr(result, 'reasoning'):
            output['reasoning'] = str(result.reasoning)
        
        return output
    
    def add_examples(self, examples: List[VulnerabilityExample]):
        """Add few-shot examples for improved detection.
        
        Args:
            examples: List of vulnerability examples
        """
        self.examples.extend(examples)
        self._setup_examples()
    
    def add_assertion(self, assertion_fn, message: str):
        """Add quality assertion for detection results.
        
        Args:
            assertion_fn: Function that returns True if assertion passes
            message: Error message if assertion fails
        """
        self.assertions.append((assertion_fn, message))
    
    def forward(self, package_name: str, package_version: str, ecosystem: str) -> dspy.Prediction:
        """Forward method for DSPy optimization.
        
        Args:
            package_name: Name of the package
            package_version: Version of the package
            ecosystem: Package ecosystem
            
        Returns:
            DSPy Prediction object
        """
        return self.predictor(
            package_name=package_name,
            package_version=package_version,
            ecosystem=ecosystem
        )


def calculate_detection_metric(prediction: Dict[str, Any], expected_cves: List[str]) -> float:
    """Calculate detection accuracy metric.
    
    Args:
        prediction: Predicted vulnerabilities
        expected_cves: List of expected CVE IDs
        
    Returns:
        Detection accuracy score between 0.0 and 1.0
    """
    if not expected_cves:
        return 1.0 if not prediction.get('vulnerabilities') else 0.0
    
    predicted_cves = set()
    for vuln in prediction.get('vulnerabilities', []):
        if 'cve_id' in vuln:
            predicted_cves.add(vuln['cve_id'])
    
    expected_set = set(expected_cves)
    
    # Calculate precision and recall
    if not predicted_cves:
        return 0.0
    
    true_positives = len(predicted_cves & expected_set)
    precision = true_positives / len(predicted_cves) if predicted_cves else 0
    recall = true_positives / len(expected_set) if expected_set else 0
    
    # F1 score
    if precision + recall == 0:
        return 0.0
    
    f1_score = 2 * (precision * recall) / (precision + recall)
    
    # Weight confidence into the metric
    confidence_weight = prediction.get('confidence', 0.5)
    
    return f1_score * confidence_weight


def create_optimized_detector(
    training_data: List[Dict[str, Any]],
    metric_fn: Optional[callable] = None,
    max_bootstrapped_demos: int = 10,
    max_labeled_demos: int = 10,
    num_iterations: int = 10
) -> VulnerabilityDetector:
    """Create an optimized vulnerability detector using DSPy optimization.
    
    Args:
        training_data: List of training examples with packages and expected CVEs
        metric_fn: Optional custom metric function
        max_bootstrapped_demos: Maximum bootstrapped demonstrations
        max_labeled_demos: Maximum labeled demonstrations
        num_iterations: Number of optimization iterations
        
    Returns:
        Optimized VulnerabilityDetector
    """
    # Prepare training examples
    trainset = []
    for item in training_data:
        package = item['package']
        expected_cves = item.get('expected_cves', [])
        
        example = dspy.Example(
            package_name=package.name,
            package_version=package.version,
            ecosystem=package.ecosystem,
            expected_cves=expected_cves
        ).with_inputs('package_name', 'package_version', 'ecosystem')
        
        trainset.append(example)
    
    # Use default metric if not provided
    if metric_fn is None:
        metric_fn = lambda pred, example: calculate_detection_metric(
            pred.dict() if hasattr(pred, 'dict') else pred,
            example.expected_cves
        )
    
    # Create base detector
    detector = VulnerabilityDetector()
    
    # Setup optimizer
    optimizer = dspy.MIPROv2(
        metric=metric_fn,
        max_bootstrapped_demos=max_bootstrapped_demos,
        max_labeled_demos=max_labeled_demos,
        num_iterations=num_iterations
    )
    
    # Optimize detector
    optimized_detector = optimizer.compile(
        detector,
        trainset=trainset,
        requires_permission_to_run=False
    )
    
    logger.info(f"Optimized vulnerability detector with {len(trainset)} training examples")
    
    return optimized_detector