"""
Unit tests for DSPy VulnerabilityDetector module.
Tests the structured signature-based vulnerability detection.
"""

import pytest
import dspy
from unittest.mock import Mock, patch, MagicMock
from typing import List, Dict, Any

from sca_ai_scanner.dspy_modules.vulnerability_detector import (
    VulnerabilitySignature,
    VulnerabilityDetector,
    VulnerabilityExample,
    create_optimized_detector
)
from sca_ai_scanner.core.models import Package, CVEFinding, Severity


class TestVulnerabilitySignature:
    """Test the DSPy signature for vulnerability detection."""
    
    def test_signature_structure(self):
        """Test that VulnerabilitySignature has correct input/output structure."""
        sig = VulnerabilitySignature()
        
        # Check input fields
        assert hasattr(sig, 'package_name')
        assert hasattr(sig, 'package_version')
        assert hasattr(sig, 'ecosystem')
        
        # Check output fields
        assert hasattr(sig, 'vulnerabilities')
        assert hasattr(sig, 'confidence')
        assert hasattr(sig, 'reasoning')
    
    def test_signature_validation(self):
        """Test signature validation for required fields."""
        sig = VulnerabilitySignature()
        
        # Test with valid data
        valid_data = {
            'package_name': 'lodash',
            'package_version': '4.17.19',
            'ecosystem': 'npm',
            'vulnerabilities': [
                {
                    'cve_id': 'CVE-2020-8203',
                    'severity': 'HIGH',
                    'cvss_score': 7.4,
                    'description': 'Prototype pollution vulnerability'
                }
            ],
            'confidence': 0.95,
            'reasoning': 'Known vulnerable version with documented CVE'
        }
        
        # Should not raise exception
        sig.validate(valid_data)
    
    def test_signature_type_hints(self):
        """Test that signature has proper type hints."""
        sig = VulnerabilitySignature()
        
        # Check type annotations
        assert sig.package_name.__class__.__name__ == 'InputField'
        assert sig.package_version.__class__.__name__ == 'InputField'
        assert sig.vulnerabilities.__class__.__name__ == 'OutputField'
        assert sig.confidence.__class__.__name__ == 'OutputField'


class TestVulnerabilityDetector:
    """Test the DSPy VulnerabilityDetector module."""
    
    @pytest.fixture
    def mock_lm(self):
        """Mock language model for testing."""
        mock = MagicMock()
        mock.request.return_value = {
            'vulnerabilities': [
                {
                    'cve_id': 'CVE-2020-8203',
                    'severity': 'HIGH',
                    'cvss_score': 7.4,
                    'description': 'Prototype pollution'
                }
            ],
            'confidence': 0.95,
            'reasoning': 'Known vulnerable version'
        }
        return mock
    
    @pytest.fixture
    def detector(self, mock_lm):
        """Create detector with mocked LM."""
        with patch('dspy.settings.lm', mock_lm):
            return VulnerabilityDetector()
    
    def test_detector_initialization(self, detector):
        """Test detector initializes with correct components."""
        assert detector is not None
        assert hasattr(detector, 'signature')
        assert hasattr(detector, 'predictor')
        assert hasattr(detector, 'examples')
    
    def test_single_package_detection(self, detector):
        """Test vulnerability detection for a single package."""
        package = Package(
            name='lodash',
            version='4.17.19',
            ecosystem='npm',
            source_locations=[]
        )
        
        result = detector.detect(package)
        
        assert result is not None
        assert 'vulnerabilities' in result
        assert 'confidence' in result
        assert len(result['vulnerabilities']) > 0
        assert result['confidence'] > 0.0
    
    def test_batch_detection(self, detector):
        """Test batch vulnerability detection."""
        packages = [
            Package(name='lodash', version='4.17.19', ecosystem='npm', source_locations=[]),
            Package(name='django', version='2.2.10', ecosystem='pypi', source_locations=[]),
            Package(name='express', version='4.17.1', ecosystem='npm', source_locations=[])
        ]
        
        results = detector.detect_batch(packages)
        
        assert len(results) == len(packages)
        for result in results:
            assert 'vulnerabilities' in result
            assert 'confidence' in result
    
    def test_detector_with_few_shot_examples(self, detector):
        """Test detector uses few-shot examples correctly."""
        # Add examples
        examples = [
            VulnerabilityExample(
                package_name='lodash',
                package_version='4.17.19',
                ecosystem='npm',
                vulnerabilities=[
                    {
                        'cve_id': 'CVE-2020-8203',
                        'severity': 'HIGH',
                        'cvss_score': 7.4,
                        'description': 'Prototype pollution vulnerability'
                    }
                ],
                confidence=0.95,
                reasoning='Exact version match with known CVE'
            )
        ]
        
        detector.add_examples(examples)
        assert len(detector.examples) == 1
        
        # Detection should use examples
        package = Package(
            name='lodash',
            version='4.17.20',  # Different version
            ecosystem='npm',
            source_locations=[]
        )
        
        result = detector.detect(package)
        assert result is not None
    
    def test_detector_handles_no_vulnerabilities(self, detector):
        """Test detector handles packages with no vulnerabilities."""
        with patch.object(detector, 'predictor') as mock_predictor:
            mock_predictor.return_value = {
                'vulnerabilities': [],
                'confidence': 0.99,
                'reasoning': 'No known vulnerabilities for this version'
            }
            
            package = Package(
                name='safe-package',
                version='1.0.0',
                ecosystem='npm',
                source_locations=[]
            )
            
            result = detector.detect(package)
            
            assert result['vulnerabilities'] == []
            assert result['confidence'] > 0.9
    
    def test_detector_error_handling(self, detector):
        """Test detector handles errors gracefully."""
        with patch.object(detector, 'predictor') as mock_predictor:
            mock_predictor.side_effect = Exception("API error")
            
            package = Package(
                name='test-package',
                version='1.0.0',
                ecosystem='npm',
                source_locations=[]
            )
            
            with pytest.raises(Exception) as exc_info:
                detector.detect(package)
            
            assert "API error" in str(exc_info.value)


class TestOptimizedDetector:
    """Test the optimized detector creation."""
    
    def test_create_optimized_detector(self):
        """Test creating an optimized detector with training data."""
        # Mock training data
        training_data = [
            {
                'package': Package(
                    name='lodash',
                    version='4.17.19',
                    ecosystem='npm',
                    source_locations=[]
                ),
                'expected_cves': ['CVE-2020-8203', 'CVE-2020-28500']
            },
            {
                'package': Package(
                    name='django',
                    version='2.2.10',
                    ecosystem='pypi',
                    source_locations=[]
                ),
                'expected_cves': ['CVE-2020-7471', 'CVE-2020-9402']
            }
        ]
        
        with patch('dspy.MIPROv2') as mock_optimizer:
            mock_optimizer.return_value.compile.return_value = Mock()
            
            detector = create_optimized_detector(
                training_data=training_data,
                metric_fn=lambda pred, expected: 0.9,
                max_bootstrapped_demos=5,
                max_labeled_demos=5
            )
            
            assert detector is not None
            mock_optimizer.return_value.compile.assert_called_once()
    
    def test_detector_metric_function(self):
        """Test the metric function for detector optimization."""
        from sca_ai_scanner.dspy_modules.vulnerability_detector import calculate_detection_metric
        
        prediction = {
            'vulnerabilities': [
                {'cve_id': 'CVE-2020-8203'},
                {'cve_id': 'CVE-2020-28500'}
            ],
            'confidence': 0.95
        }
        
        expected = ['CVE-2020-8203', 'CVE-2020-28500', 'CVE-2021-12345']
        
        # Should detect 2 out of 3 expected CVEs
        score = calculate_detection_metric(prediction, expected)
        assert score > 0.6  # At least 66% detection rate
        assert score < 1.0  # Not perfect since missed one
    
    def test_detector_with_assertions(self):
        """Test detector with DSPy assertions for quality control."""
        detector = VulnerabilityDetector()
        
        # Add assertion for confidence threshold
        detector.add_assertion(
            lambda result: result['confidence'] >= 0.7,
            "Confidence must be at least 0.7"
        )
        
        with patch.object(detector, 'predictor') as mock_predictor:
            # Test passing assertion
            mock_predictor.return_value = {
                'vulnerabilities': [],
                'confidence': 0.8,
                'reasoning': 'High confidence result'
            }
            
            package = Package(
                name='test',
                version='1.0.0',
                ecosystem='npm',
                source_locations=[]
            )
            
            result = detector.detect(package)
            assert result['confidence'] >= 0.7
            
            # Test failing assertion
            mock_predictor.return_value = {
                'vulnerabilities': [],
                'confidence': 0.5,
                'reasoning': 'Low confidence result'
            }
            
            with pytest.raises(AssertionError):
                detector.detect(package)


@pytest.mark.integration
class TestDSPyIntegration:
    """Integration tests for DSPy with actual models (mocked)."""
    
    def test_end_to_end_detection_flow(self):
        """Test complete detection flow with DSPy."""
        with patch('dspy.OpenAI') as mock_openai:
            mock_openai.return_value.request.return_value = {
                'vulnerabilities': [
                    {
                        'cve_id': 'CVE-2020-8203',
                        'severity': 'HIGH',
                        'cvss_score': 7.4,
                        'description': 'Prototype pollution'
                    }
                ],
                'confidence': 0.95,
                'reasoning': 'Version matches known vulnerable range'
            }
            
            # Configure DSPy
            dspy.settings.configure(lm=mock_openai())
            
            # Create and use detector
            detector = VulnerabilityDetector()
            
            package = Package(
                name='lodash',
                version='4.17.19',
                ecosystem='npm',
                source_locations=[]
            )
            
            result = detector.detect(package)
            
            assert result is not None
            assert len(result['vulnerabilities']) == 1
            assert result['vulnerabilities'][0]['cve_id'] == 'CVE-2020-8203'